// FIXME: move me to a dependency instead
syntax = "proto2";

package main;

message Group {
	required bytes uid = 1;
	required uint64 epoch = 2;
	required bytes seed = 3;

	required bytes conf_trans_hash = 4;
	required bytes interim_trans_hash = 5;

	required Roster roster = 6;

	repeated PendingUpdateEntry pending_updates = 7;
	repeated PendingCommitEntry pending_commits = 8;

	required bytes user_id = 9;
	required bytes ilum_dk = 10;
	required bytes x448_dk = 11;
	required bytes ssk = 12;

	required EpochSecrets secrets = 13;
}

message ChainTree {
	map<uint32, Chain> chains = 1;
	required SecretTree secret_tree = 2;
	required uint32 max_keys_to_skip = 3;
}

message Chain {
	map<uint32, bytes> skipped_keys = 1;
	required bytes next_key = 2;
	required uint32 next_idx = 3;
	required uint32 max_keys_to_skip = 4;
}

message SecretTree {
	required uint32 group_size = 1;
	required uint32 root = 2;
	map<uint32, bytes> secrets = 3;
}

message EpochSecrets {
	required bytes init = 1;
	required bytes mac = 2;
	required ChainTree hs = 3;
	required ChainTree app = 4;
}

message PendingCommit {
	// the new state
	required Group state = 2;
	// ids of framed proposals to ensure no proposals have been received since the commit was sent to the backend
	repeated bytes proposals = 3;
}

// wraps PendingCommit to support bytes keys for map
message PendingCommitEntry {
	required bytes id = 1;
	required PendingCommit commit = 2;
}

message PendingUpdate {
	required bytes ilum_dk = 2;
	required bytes x448_dk = 3;
	required bytes ssk = 4;
}

// wraps PendingUpdate to support bytes keys for map
message PendingUpdateEntry {
	required bytes id = 1;
	required PendingUpdate upd = 2;
}

message KeyPackage {
	required bytes ilum_ek = 1;
	required bytes x448_ek = 2;
	required bytes svk = 3;
	required bytes sig = 4;
}

message Member {
	required bytes id = 1;
	required KeyPackage kp = 2;
}

message Roster {
	repeated Member members = 1;
}

message GroupInfo {
	required bytes guid = 1;
	required uint64 epoch = 2;
	required Roster roster = 3;
	required bytes conf_trans_hash = 4;
	required bytes conf_tag = 5;
	required bytes inviter = 6;
	required bytes joiner = 7;
}

message Prop {
	message Remove {
		required bytes id = 1;
	}

	message Update {
		required KeyPackage kp = 1;
	}

	message Add {
		required bytes id = 1;
		required KeyPackage kp = 2;
	}

	oneof variant {
		// option (validate.required) = true;
		Remove remove = 1;
		Update update = 2;
		Add add = 3;
	}
}

message FramedProposal {
	required bytes guid = 1;
	required uint64 epoch = 2;
	required bytes sender = 3;
	required Prop prop = 4;
	required bytes sig = 5;
	required bytes mac = 6;
	required bytes nonce = 7;
}

message CmpdCti {
	// encrypted payload
	required bytes ct = 1;
	// encrypted x448 key used to encrypt the payload
	required bytes encrypted_eph_key = 2;
	// iv used to encrypt the x448 key
	required bytes iv = 3;
	// ilum key-independent ct used to encrypt the x448 key (should be combined with its corresponding ctd part to decrypt)
	required bytes ilum_cti = 4;
}

message CmpdCtd {
	required bytes ilum_ctd = 1;
	required bytes ecc_ctd = 2;
}

message Commit {
	required KeyPackage kp = 1;
	required CmpdCti cti = 2;
	repeated bytes prop_ids = 3;
}

message FramedCommit {
	required bytes guid = 1;
	required uint64 epoch = 2;
	required bytes sender = 3;
	required Commit commit = 4;
	required bytes sig = 5;
	required bytes conf_tag = 6;
}

message CommitCtd {
	required bytes user_id = 1;
	// nil for evictees
	optional CmpdCtd ctd = 2;
}

message Ciphertext {
	// TODO: timestamp against replay attacks?
	required bytes content_id = 1;
	required bytes payload = 2;
	required bytes guid = 3;
	required uint64 epoch = 4;
	required uint32 gen = 5;
	required bytes sender = 6;
	required bytes iv = 7;
	required bytes sig = 8;
	required bytes mac = 9;
	required bytes reuse_grd = 10;
}

message WlcmCti {
	required CmpdCti cti = 1;
	required bytes sig = 2;
}

message WlcmCtd {
	required bytes user_id = 1;
	required bytes kp_id = 2;
	required CmpdCtd ctd = 3;
}

message SendCommit {
	// for the backend to fanout this:
	// ctds.for_each(|ctd| {
	//	send_to(ctd.user_id, ReceivedCommit { cti, ctd.ctd })
	// })
	required Ciphertext cti = 1;
	repeated CommitCtd ctds = 2;
}

// FIXME: introduce LEAVE

// combines a set of proposals into one
message SendProposal {
	// each proposal is sent to each of the recipients below
	repeated Ciphertext props = 1;
	repeated bytes recipients = 2;
}

message SendMsg {
	required Ciphertext payload = 1;
	repeated bytes recipients = 2;
}

message SendAdd {
	// commit & each prop is sent to commit.ctds.user_id
	repeated Ciphertext props = 1;
	required SendCommit commit = 2;
}

message SendInvite {
	// for the backend to fanout this:
	// wctds.for_each(|ctd| {
	//	send_to(ctd.user_id, ReceivedWlcm { wcti, ctd.ctd, ctd.kp_id })
	// })
	// welcome cti
	required WlcmCti wcti = 1;
	// welcome ctds
	repeated WlcmCtd wctds = 2;
	// props & commit sent to the existing peers, if any; nil, if the group has just been created
	optional SendAdd add = 3;
}

message SendRemove {
	// commit & each prop is sent to commit.ctds.user_id
	repeated Ciphertext props = 1;
	required SendCommit commit = 2;
}

message Send {
	oneof variant {
		// a combined (props, commit)
		SendInvite invite = 1;
		// a combined (props, commit)
		SendRemove remove = 2;
		// usually just update proposals, but can be more generic
		SendProposal props = 3; 
		// update commit, but can be more generic
		SendCommit commit = 4; 
		// an arbitrary app message
		SendMsg msg = 5;
	}
}

message ReceivedWelcome {
	required WlcmCti cti = 1;
	required CmpdCtd ctd = 2;
	required bytes kp_id = 3;
}

message ReceivedCommit {
	required Ciphertext cti = 1;
	required CmpdCtd ctd = 2; 
}

message ReceivedProposal {
	repeated Ciphertext props = 1;
}

message ReceivedAdd {
	required ReceivedProposal props = 1;
	required ReceivedCommit commit = 2;
}

message ReceivedRemove {
	required ReceivedProposal props = 1;
	// commit cti & ctd
	required Ciphertext cti = 2;
	// nil if evicted
	optional CmpdCtd ctd = 3; 
}

message Received {
	oneof variant {
		ReceivedWelcome wlcm = 1;
		ReceivedAdd add = 2;
		ReceivedRemove remove = 3;
		// update proposals, but can be more generic
		ReceivedProposal props = 4;
		// update commit, but can be more generic
		ReceivedCommit commit = 5;
		// an arbitrary app message
		Ciphertext msg = 6;
	}
}

// access management built on top of qydra
// message SetAccessLevel {
// 	required bytes user_id = 1;
// 	required bool admin = 2;
// }

// // group meta information
// message GroupMeta {
// 	optional string name = 1;
// 	optional string description = 2;
// 	// admin ids
// 	repeated bytes admins = 3;
// 	required bytes owner = 4;
// }