// FIXME: move me to a dependency instead
syntax = "proto2";

package main;

message KeyPackage {
	required bytes ilum_ek = 1;
	required bytes x448_ek = 2;
	required bytes svk = 3;
	required bytes sig = 4;
}

message Member {
	required bytes id = 1;
	required KeyPackage kp = 2;
}

message Roster {
	repeated Member members = 1;
}

message GroupInfo {
	required bytes guid = 1;
	required uint64 epoch = 2;
	required Roster roster = 3;
	required bytes conf_trans_hash = 4;
	required bytes conf_tag = 5;
	required bytes inviter = 6;
	required bytes joiner = 7;
}

message Prop {
	message Remove {
		required bytes id = 1;
	}

	message Update {
		required KeyPackage kp = 1;
	}

	message Add {
		required bytes id = 1;
		required KeyPackage kp = 2;
	}

	oneof variant {
		// option (validate.required) = true;

		Remove remove = 1;
		Update update = 2;
		Add add = 3;
	}
}

message FramedProposal {
	required bytes guid = 1;
	required uint64 epoch = 2;
	required bytes sender = 3;
	required Prop prop = 4;
	required bytes sig = 5;
	required bytes mac = 6;
	required bytes nonce = 7;
}

message CmpdCti {
	// encrypted payload
	required bytes ct = 1;
	// encrypted x448 key used to encrypt the payload
	required bytes encrypted_eph_key = 2;
	// iv used to encrypt the x448 key
	required bytes iv = 3;
	// ilum key-independent ct used to encrypt the x448 key (should be combined with its corresponding ctd part to decrypt)
	required bytes ilum_cti = 4;
}

message CmpdCtd {
	required bytes ilum_ctd = 1;
	required bytes ecc_ctd = 2;
}

message Commit {
	required KeyPackage kp = 1;
	required CmpdCti cti = 2;
	repeated bytes prop_ids = 3;
}

message FramedCommit {
	required bytes guid = 1;
	required uint64 epoch = 2;
	required bytes sender = 3;
	required Commit commit = 4;
	required bytes sig = 5;
	required bytes conf_tag = 6;
}

message CommitCtd {
	required bytes user_id = 1;
	// nil for evictees
	optional CmpdCtd ctd = 2;
}

enum ContentType {
	App = 1;
	Propsl = 2;
	Commt = 3;
}

message Ciphertext {
	// TODO: timestamp against replay attacks?
	required ContentType content_type = 1;
	required bytes content_id = 2;
	required bytes payload = 3;
	required bytes guid = 4;
	required uint64 epoch = 5;
	required uint32 gen = 6;
	required bytes sender = 7;
	required bytes iv = 8;
	required bytes sig = 9;
	required bytes mac = 10;
	required bytes reuse_grd = 11;
}

message WlcmCti {
	required CmpdCti cti = 1;
	required bytes sig = 2;
}

message WlcmCtd {
	required bytes user_id = 1;
	required bytes key_id = 2;
	required CmpdCtd ctd = 3;
}

message SendWelcome {
	// for the backend to fanout this:
	// ctds.for_each(|ctd| {
	//	send_to(ctd.user_id, ReceivedWlcm { cti, ctd.ctd, ctd.key_id })
	// })
	required WlcmCti cti = 1;
	repeated WlcmCtd ctds = 2;
}

message SendCommit {
	// for the backend to fanout this:
	// ctds.for_each(|ctd| {
	//	send_to(ctd.user_id, ReceivedCommit { cti, ctd.ctd })
	// })
	required Ciphertext cti = 1;
	repeated CommitCtd ctds = 2;
}

message SendProposal {
	repeated SendCiphertext props = 1;
}

message SendCiphertext {
	required bytes user_id = 1;
	required Ciphertext payload = 2;
}

// // sent by clients and processed by the backend
// message Send {
// 	// several welcomes can be sent when someone is invited
// 	optional SendWelcome wlcms = 1;
// 	// and/or one commit
// 	optional SendCommit commit = 2;
// 	// and/or several proposals
// 	optional SendProposal props = 3;
// 	// or a message
// 	optional SendCiphertext app_msg = 4;
// }

message Send {
	message Add {
		required SendCommit commit = 1;
		required SendProposal props = 2;
	}

	message Invite {
		required SendWelcome wlcm = 1;
		optional Add add = 2;
	}
	
	message Remove {
		required SendCommit commit = 1;
		required SendProposal props = 2;
	}

	oneof variant {
		Invite invite = 1;
		Remove remove = 2;
		SendProposal props = 3; // update proposals; TODO: SendCiphertext instead? It's just one update proposal
		SendCommit commit = 4; // update commit
		SendCiphertext msg = 5;
	}
}

message ReceivedWelcome {
	required WlcmCti cti = 1;
	required CmpdCtd ctd = 2;
	required bytes key_id = 3;
}

message ReceivedCommit {
	required Ciphertext cti = 1;
	// nil if evicted
	optional CmpdCtd ctd = 2; 
}

message ReceivedProposal {
	repeated Ciphertext props = 1;
}

message Received {
	message Add {
		required ReceivedCommit commit = 1;
		required ReceivedProposal props = 2;
	}
	message Remove {
		required ReceivedCommit commit = 1;
		required ReceivedProposal props = 2;
	}

	oneof variant {
		ReceivedWelcome wlcm = 1;
		Add add = 2;
		Remove remove = 3;
		ReceivedProposal props = 4; // update proposals
		ReceivedCommit commit = 5;
		Ciphertext msg = 6;
	}
}

// // sent by the backend and processed by clients
// message Received {
// 	// either a welcome
// 	optional ReceivedWelcome wlcm = 1;
// 	// or a commit
// 	optional ReceivedCommit commit = 2;
// 	// and/or several proposals
// 	optional ReceivedProposal props = 3;
// 	// or a message
// 	optional Ciphertext app_msg = 4;
// }